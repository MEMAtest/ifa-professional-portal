// app/api/assessments/vulnerability/route.ts
// ================================================================
// VULNERABILITY ASSESSMENT API
// Save and retrieve vulnerability assessments
// ================================================================

import { NextRequest, NextResponse } from 'next/server'
import { log } from '@/lib/logging/structured'
import { getSupabaseServiceClient } from '@/lib/supabase/serviceClient'
import { getAuthContext, requireFirmId, requirePermission } from '@/lib/auth/apiAuth'
import { requireClientAccess } from '@/lib/auth/requireClientAccess'
import { parseRequestBody } from '@/app/api/utils'
import { rateLimit } from '@/lib/security/rateLimit'

export const dynamic = 'force-dynamic'

// GET - Retrieve Vulnerability Assessment
export async function GET(request: NextRequest) {
  try {
    const auth = await getAuthContext(request)
    if (!auth.success || !auth.context) {
      return auth.response || NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })
    }
    const firmResult = requireFirmId(auth.context)
    if (!('firmId' in firmResult)) {
      return firmResult
    }
    const permissionError = requirePermission(auth.context, 'assessments:read')
    if (permissionError) {
      return permissionError
    }
    const { firmId } = firmResult

    const { searchParams } = new URL(request.url)
    const clientId = searchParams.get('clientId')

    if (!clientId) {
      return NextResponse.json(
        { success: false, error: 'Client ID is required' },
        { status: 400 }
      )
    }

    const supabase = getSupabaseServiceClient() as any
    const access = await requireClientAccess({
      supabase,
      clientId,
      ctx: auth.context,
      select: 'id, firm_id, advisor_id'
    })
    if (!access.ok) {
      return access.response
    }

    // Try to get from vulnerability_assessments table
    const { data: assessment, error } = await supabase
      .from('vulnerability_assessments')
      .select('*')
      .eq('client_id', clientId)
      .eq('firm_id', firmId)
      .order('assessed_at', { ascending: false })
      .limit(1)
      .maybeSingle()

    if (error && error.code !== 'PGRST116') {
      // If table doesn't exist or other error, return empty
      if (error.code === '42P01' || error.message?.includes('does not exist')) {
        return NextResponse.json({
          success: true,
          assessment: null,
          message: 'Vulnerability assessments table not yet created'
        })
      }
      throw error
    }

    return NextResponse.json({
      success: true,
      assessment: assessment ? {
        id: assessment.id,
        clientId: assessment.client_id,
        isVulnerable: assessment.is_vulnerable,
        vulnerabilityFactors: assessment.vulnerability_factors,
        healthFactors: assessment.health_factors,
        lifeEventsFactors: assessment.life_events_factors,
        resilienceFactors: assessment.resilience_factors,
        capabilityFactors: assessment.capability_factors,
        overallRiskLevel: assessment.overall_risk_level,
        supportMeasures: assessment.support_measures,
        notes: assessment.notes,
        assessedBy: assessment.assessed_by,
        assessedAt: assessment.assessed_at,
        reviewDate: assessment.review_date,
        createdAt: assessment.created_at,
        updatedAt: assessment.updated_at
      } : null
    })
  } catch (error) {
    log.error('Error fetching vulnerability assessment', error)
    return NextResponse.json(
      { success: false, error: 'Failed to fetch assessment' },
      { status: 500 }
    )
  }
}

// POST - Save Vulnerability Assessment
export async function POST(request: NextRequest) {
  try {
    const rateLimitResponse = await rateLimit(request, 'api')
    if (rateLimitResponse) {
      return rateLimitResponse
    }

    const auth = await getAuthContext(request)
    if (!auth.success || !auth.context) {
      return auth.response || NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 })
    }
    const firmResult = requireFirmId(auth.context)
    if (!('firmId' in firmResult)) {
      return firmResult
    }
    const permissionError = requirePermission(auth.context, 'assessments:write')
    if (permissionError) {
      return permissionError
    }
    const { firmId } = firmResult

    const body = await parseRequestBody(request)
    const {
      clientId,
      isVulnerable,
      vulnerabilityFactors,
      healthFactors,
      lifeEventsFactors,
      resilienceFactors,
      capabilityFactors,
      overallRiskLevel,
      supportMeasures,
      notes,
      assessedBy
    } = body

    if (!clientId) {
      return NextResponse.json(
        { success: false, error: 'Client ID is required' },
        { status: 400 }
      )
    }

    const supabase = getSupabaseServiceClient() as any
    const access = await requireClientAccess({
      supabase,
      clientId,
      ctx: auth.context,
      select: 'id, firm_id, advisor_id'
    })
    if (!access.ok) {
      return access.response
    }

    const now = new Date().toISOString()

    const assessmentRecord = {
      client_id: clientId,
      firm_id: firmId || null,
      is_vulnerable: isVulnerable || false,
      vulnerability_factors: vulnerabilityFactors || [],
      health_factors: healthFactors || {},
      life_events_factors: lifeEventsFactors || {},
      resilience_factors: resilienceFactors || {},
      capability_factors: capabilityFactors || {},
      overall_risk_level: overallRiskLevel || 'low',
      support_measures: supportMeasures || [],
      notes: notes || null,
      assessed_by: assessedBy || null,
      assessed_at: now,
      review_date: null, // Set review date based on risk level
      created_at: now,
      updated_at: now
    }

    // Try to insert/update
    const { data: existingAssessment } = await supabase
      .from('vulnerability_assessments')
      .select('id')
      .eq('client_id', clientId)
      .eq('firm_id', firmId)
      .maybeSingle()

    let result
    if (existingAssessment) {
      // Update existing
      result = await supabase
        .from('vulnerability_assessments')
        .update({ ...assessmentRecord, created_at: undefined })
        .eq('id', existingAssessment.id)
        .eq('firm_id', firmId)
        .select()
        .single()
    } else {
      // Insert new
      result = await supabase
        .from('vulnerability_assessments')
        .insert(assessmentRecord)
        .select()
        .single()
    }

    if (result.error) {
      // If table doesn't exist, return helpful error
      if (result.error.code === '42P01' || result.error.message?.includes('does not exist')) {
        return NextResponse.json({
          success: false,
          error: 'Vulnerability assessments table not yet created. Please run database migrations.'
        }, { status: 503 })
      }
      throw result.error
    }

    return NextResponse.json({
      success: true,
      message: 'Assessment saved successfully',
      assessmentId: result.data.id,
      savedAt: now
    })
  } catch (error) {
    log.error('Error saving vulnerability assessment', error)
    return NextResponse.json(
      { success: false, error: 'Failed to save assessment' },
      { status: 500 }
    )
  }
}
